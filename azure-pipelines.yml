trigger:
  branches:
    include: ["main", "develop*", "release-*", "refs/tags/*" ]
  paths:
    exclude: [ "doc", "*.md", ".gitignore", "README.md", "LICENSE.md" ]

# PR always trigger build
pr:
  autoCancel: true

# add nf-tools repo to resources (for Azure Pipelines templates)
resources:
  repositories:
    - repository: templates
      type: github
      name: nanoframework/nf-tools
      endpoint: nanoframework

pool:
  vmImage: 'windows-2019'

variables:
  DOTNET_NOLOGO: true
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'

steps:

# need this here in order to persist GitHub credentials 
- checkout: self
  fetchDepth: 1
  submodules: true

- script: |
    git config --global user.email "nanoframework@outlook.com"
    git config --global user.name "nfbot"
    git config --global core.autocrlf true
  displayName: Setup git identity

- task: NuGetToolInstaller@1
  condition: and( succeeded(), ne( variables['StartReleaseCandidate'], true ) )
  displayName: 'Install specific version of NuGet'
  inputs:
    versionSpec: '>=5.9.x'

# buil solutions that need to be build
- powershell: |
    $auth = "basic $([System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(":$(GitHubToken)"))))"
  
    if($env:System_PullRequest_PullRequestId -ne $null)
    {
        # get files changed in PR, if this is a PR
        $commit = Invoke-RestMethod -Uri "https://api.github.com/repos/nanoframework/nanoFramework.IoT.Device/pulls/$env:System_PullRequest_PullRequestNumber/files" -Header @{"Authorization"="$auth"} -ContentType "application/json" -Method GET

        # filter removed files              
        $files = $commit.where{$_.status -ne 'removed'}
    }
    else
    {
        # get files changed in the commit, if this is NOT a PR
        $commit = Invoke-RestMethod -Uri "https://api.github.com/repos/nanoframework/nanoFramework.IoT.Device/commits/$(Build.SourceVersion)" -Header @{"Authorization"="$auth"} -ContentType "application/json" -Method GET

        # filter removed files              
        $files = $commit.files.where{$_.status -ne 'removed'}
    }

    # get file names only
    $files1 = $files | % {$_.filename} | Where-Object {$_ -match 'src/devices*'} 

    Write-host "Files changed:"
    $files1 | % { Write-host $_ }
    Write-host ""

    # pattern to select device folder name
    $pattern = '(devices\/)(?<folder>\w+)'

    # filter out the collection
    $results = [Regex]::Matches($files1, $pattern)

    # get unique folder names
    $deviceFolders = $results | Sort-Object |  Select-Object | Foreach-Object {$_.Groups["folder"].Value} | Get-Unique 

    foreach ($folder in $deviceFolders)
    {
        Write-host "Processing '$folder'"
        
        # find solution
        $solutionFile = Get-ChildItem -Path "src\devices\$folder\" -Include "*.sln" -Recurse

        # find nuspec
        $nuspecFile = Get-ChildItem -Path "src\devices\$folder\" -Include "*.nuspec" -Recurse

        if($null -eq $solutionFile)
        {
            Write-host "Couldn't find any solution file!"
        }
        else
        {
            # need to restore NuGets first
            nuget restore $solutionFile

            # build solution
            msbuild $solutionFile -t:Rebuild -p:Configuration=Release;platform="Any CPU"

            # package NuGet
            nuget pack $nuspecFile -Version 1.0.0.0 -properties commit="$(Build.SourceVersion)" -OutputDirectory $env:Agent_TempDirectory
        }
    }

- task: CopyFiles@1
  condition: succeeded()
  displayName: Collecting deployable artifacts
  inputs:
    sourceFolder: $(Agent.TempDirectory)
    Contents: |
      *.nupkg
    TargetFolder: '$(Build.ArtifactStagingDirectory)'
    flattenFolders: true

# publish artifacts (only possible if this is not a PR originated on a fork)
- task: PublishBuildArtifacts@1
  condition: succeeded()
  displayName: Publish deployables artifacts
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: deployables
    ArtifactType: Container
  
# step from template @ nf-tools repo
# report error
- template: azure-pipelines-templates/discord-webhook-task.yml@templates  
  parameters:
    status: 'failure'
    webhookUrl: '$(DiscordWebhook)'
    message: ''
